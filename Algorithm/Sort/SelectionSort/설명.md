## Selection Sort

[3, 5, 4, 2, 1]  

선택 정렬은 배열을 돌면서  
가장 작은 값부터 하나씩 앞으로 하나씩 차곡차곡 옮기는 것.  

작은 값을 앞으로 옮기기 위해서는  
가장 작은 값을 찾아야겠죠

배열을 돌면서 가장 작은 값을 저장할 변수 min을 선언하고요  
현재로써 가장 작은 값을 모르니까 배열의 시작 값으로 초기화합니다.
따라서 min = 3입니다.  

이제 배열방을 돌면서 가장 작은 값을 찾습니다.  
5는 3보다 크니까 넘어가고, 4도 3보다 크니까 그냥 넘어가고, 2는 3보다 작으니까  
min을 2로 조정해줍니다. ==> min = 2  
그리고 다음 방을 보니까 더 작은 값인 1이 나왔죠  
그러면 min을 다시 1로 바꿔줍니다. ==> min = 1  


처음부터 배열의 끝까지 다 돌았으므로, 지금 이 숫자(1)가 배열 안에서 가장 작은 숫자입니다.
그러면 이 가장 작은 값을 맨 앞에 있는 데이터와 교체해줍니다.
[1, 5, 4, 2, 3]
이러면 첫번째 방은 정렬이 된거에요  

또 다시 다음 방부터 시작해서 가장 작은 값을 찾아 나섭니다.  

우선 작은 값(min)을 시작 값으로 초기화를 하고, 4가 더 작으니까 min을 4로 바꾸어줍니다. ==> min = 4  
다음 방을 보니 2가 더 작으니까 min을 2로 바꾸어 주고, ==> min = 2  
다음 방의 3은 2보다 크니까 최종적으로 2가 가장 작은 값이다.  

이제 정렬이 안된 방의 가장 첫번 째 방의 5와 2를 교체해 줍니다.  
[1, 2, 4, 5, 3]  
이러면 두번째 방까지 정렬이 된거에요.  

다시 min = 4로 두고, 5는 4보다 크고, 3은 4보다 작으므로 ==> min=3 으로 설정해줍니다.  
이제 첫번째 방의 4와 3을 바꾸어줍니다.  
[1, 2, 3, 5, 4]  
그러면 이제 3번째 방까지 정렬이 된거에요.  

다시 5로 작은 값을 초기화하고 ==> min = 5  
4가 더 작으니까, min을 4로 바꾸어줍니다. ==> min = 4  
이제 시작점에 있었던 값(5)와 바꾸어줍니다.  
[1, 2, 3, 4, 5]  

이렇게 반복해서 배열의 끝까지 왔으니까 정렬이 다 된거에요.  
이 정렬 방법은 앞에서부터 한칸씩 가면서 갈 때마다 전체 배열방을 한번씩 다시 돌기 때문에 O(n^2)  

물론 한 번 돌때마다 왼쪽에서 하나 뺀 만큼씩 빠지지만 결국 Big-O는 O(n^/2)꼴이 되어서 Big-O가 O(n^2)임은 동일합니다.
그리고 최선의 경우로 인풋이 주어지더라도 방을 탐색하는 방식이 달라지지 않으므로 최선의 상황에서도 Big-O는 O(n^2)입니다.


백준 23882번  
역순으로 큰 값을 가장 우측 방부터 채워나가서 오름차순을 만드는 문제 (위의 방법과 역순)